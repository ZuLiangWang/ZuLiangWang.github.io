<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>okhttp源码分析 | Hexo|王祖亮</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在前一段时间已经学习了Retrofit和Okhttp的基本用法，今天我就要开始第三部分Why的学习。第一次认真的阅读一个第三方开源库的内部代码，深入理解okttp和Retroft的实现过程，由于Retrofit的网络通讯的实现全部基于okhttp，因此首先我将开始对okhttp源码的学习。
按照惯例，我分三部分开始对okhttp的解析。###1.What?okhttp是什么？它有什么用？我直接引用">
<meta property="og:type" content="article">
<meta property="og:title" content="okhttp源码分析">
<meta property="og:url" content="http://yoursite.com/2016/02/26/okhttp源码分析/index.html">
<meta property="og:site_name" content="Hexo|王祖亮">
<meta property="og:description" content="在前一段时间已经学习了Retrofit和Okhttp的基本用法，今天我就要开始第三部分Why的学习。第一次认真的阅读一个第三方开源库的内部代码，深入理解okttp和Retroft的实现过程，由于Retrofit的网络通讯的实现全部基于okhttp，因此首先我将开始对okhttp源码的学习。
按照惯例，我分三部分开始对okhttp的解析。###1.What?okhttp是什么？它有什么用？我直接引用">
<meta property="og:image" content="http://d.pcs.baidu.com/thumbnail/993b67199dbbd8f5341fc33c0bd42096?fid=2104252820-250528-951178632980765&time=1456556400&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2BtawZrwj0f9j%2BNGjiiErCzGP5k%3D&rt=sh&expires=2h&r=526005079&sharesign=unknown&size=c710_u500&quality=100">
<meta property="og:updated_time" content="2016-02-27T07:42:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="okhttp源码分析">
<meta name="twitter:description" content="在前一段时间已经学习了Retrofit和Okhttp的基本用法，今天我就要开始第三部分Why的学习。第一次认真的阅读一个第三方开源库的内部代码，深入理解okttp和Retroft的实现过程，由于Retrofit的网络通讯的实现全部基于okhttp，因此首先我将开始对okhttp源码的学习。
按照惯例，我分三部分开始对okhttp的解析。###1.What?okhttp是什么？它有什么用？我直接引用">
  
    <link rel="alternative" href="/atom.xml" title="Hexo|王祖亮" type="application/atom+xml">
  
  
    <link rel="icon" href="/32.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/touxiang.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">王祖亮</a></h1>
		</hgroup>

		
		<p class="header-subtitle">一只码畜</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/ZuLiangWang" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Hust Cser / Android Coder      zuliangwang@hustunique.com  329851721@qq.com</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王祖亮</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/touxiang.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王祖亮</h1>
			</hgroup>
			
			<p class="header-subtitle">一只码畜</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/ZuLiangWang" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-okhttp源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/26/okhttp源码分析/" class="article-date">
  	<time datetime="2016-02-26T11:12:59.000Z" itemprop="datePublished">2016-02-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      okhttp源码分析
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="在前一段时间已经学习了Retrofit和Okhttp的基本用法，今天我就要开始第三部分Why的学习。第一次认真的阅读一个第三方开源库的内部代码，深入理解okttp和Retroft的实现过程，由于Retrofit的网络通讯的实现全部基于okhttp，因此首先我将开始对okhttp源码的学习。">在前一段时间已经学习了Retrofit和Okhttp的基本用法，今天我就要开始第三部分Why的学习。第一次认真的阅读一个第三方开源库的内部代码，深入理解okttp和Retroft的实现过程，由于Retrofit的网络通讯的实现全部基于okhttp，因此首先我将开始对okhttp源码的学习。</h5><hr>
<h2 id="按照惯例，我分三部分开始对okhttp的解析。">按照惯例，我分三部分开始对okhttp的解析。</h2><p>###1.What?<br>okhttp是什么？它有什么用？我直接引用官方的介绍如下</p>
<blockquote>
<p>Overview</p>
<p>HTTP is the way modern applications network. It’s how we exchange data &amp; media. Doing HTTP efficiently makes your stuff load faster and saves bandwidth.<br>OkHttp is an HTTP client that’s efficient by default:</p>
<p>HTTP/2 support allows all requests to the same host to share a socket.<br>Connection pooling reduces request latency (if HTTP/2 isn’t available).<br>Transparent GZIP shrinks download sizes.<br>Response caching avoids the network completely for repeat requests.<br>OkHttp perseveres when the network is troublesome: it will silently recover from common connection problems. If your service has multiple IP addresses OkHttp will attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6 and for services hosted in redundant data centers. OkHttp initiates new connections with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake fails.</p>
<p>Using OkHttp is easy. Its request/response API is designed with fluent builders and immutability. It supports both synchronous blocking calls and async calls with callbacks.</p>
<p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
</blockquote>
<p>根据官方介绍：okhttp是一个应用网络库，它可以帮助我们用更少的带宽和更快的速度去交换数据，有用的使用HTTP。<br>它默认具有以下功能：</p>
<ul>
<li>允许我们发向同一个服务器的请求分享socket</li>
<li>使用链接池的设计来减少请求的延迟</li>
<li>使用GZIP压缩方式减少从服务端下载的数据量</li>
<li>对服务端的回应使用cache避免多次发送完全相同的请求<br>okhttp使用重连机制，当网络出现问题时，它会静默的恢复，并且当你连接的服务有多个IP地址时，它会在第一个连接失败后调用第二个去尝试。<br>okhttp同时支持同步调用和异步调用。</li>
</ul>
<hr>
<p>###2&amp;3.How&amp;Why?</p>
<p>首先从我们的使用过程开始一步一步深入到内部的实现。<br>我们先来看每次使用okhttp的最简单流程。</p>
<p>获取一个URL的内容</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个okhttpclient对象</span></span><br><span class="line">OkHttpClient mOkHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="comment">//创建一个Request</span></span><br><span class="line"><span class="keyword">final</span> Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"www.baidu.com"</span>)</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">//创建一个新的call</span></span><br><span class="line"><span class="keyword">Call</span> <span class="keyword">call</span> = mOkHttpClient.newCall(request); </span><br><span class="line"><span class="comment">//令call进入队列等待执行</span></span><br><span class="line"><span class="keyword">call</span>.enqueue(<span class="keyword">new</span> Callback()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onFailure(Request request, IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onResponse(<span class="keyword">final</span> Response response) <span class="keyword">throws</span> IOException</span><br><span class="line">            &#123;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);       </span><br><span class="line">```      </span><br><span class="line">这是一个典型的最简单的使用方式。</span><br><span class="line"></span><br><span class="line">来简单分析一下它的使用过程。</span><br><span class="line"><span class="number">1</span>.创建一个OkhttpClient对象，这是使用okhttp所有功能的第一步。</span><br><span class="line"><span class="number">2</span>.创建一个Request对象，这个过程使用了建造者模式，这个模式的优点是简化繁琐的初始化过程，使对象的创建与内部的实现分离，让客户端用户可以更精细的根据自己的需求创造对应的对象。我们可以看到，使用了建造者模式，request的创建逻辑变得非常清晰，在这里例子中我们只设置了url，但根据需求我们可以创建复杂得多的request。</span><br><span class="line"><span class="number">3</span>.调用client的方法将request封装成一个<span class="keyword">call</span>，在okhttp中request并不能被直接执行，需要对request进行封装，在最后执行<span class="keyword">call</span>。</span><br><span class="line"><span class="number">4</span>.执行封装好的<span class="keyword">call</span>。查看源码可以看到okhttp为我们提供了两种执行方式，execute()和enqueue()，这两种方式的区别从名字上就能看出来大概，稍后我详细分析。注意，查看源码的注释可以看到</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>A call is a request that has been prepared for execution. A call can be</li>
<li>canceled. As this object represents a single request/response pair (stream),</li>
<li>it cannot be executed twice.<br>*/</li>
</ul>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里明确的指出了一个<span class="keyword">call</span>对象只能被执行一次，所以如果想要多次执行相同的<span class="built_in">request</span>，我们还需要另想办法。</span><br><span class="line"></span><br><span class="line">好了，下面我们开始从源码入手，分析一个<span class="built_in">request</span>从创建到被执行的所有过程。</span><br><span class="line">我们每一次使用都要创建OkhttpClient。</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>Configures and creates HTTP connections. Most applications can use a single</li>
<li>OkHttpClient for all of their HTTP requests - benefiting from a shared</li>
<li>response cache, thread pool, connection re-use, etc.<br>*</li>
<li><p>Instances of OkHttpClient are intended to be fully configured before they’re</p></li>
<li>shared - once shared they should be treated as immutable and can safely be used</li>
<li>to concurrently open new connections. If required, threads can call</li>
<li>{@link #clone()} to make a shallow copy of the OkHttpClient that can be</li>
<li><p>safely modified with further configuration changes.<br>*/</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是官方对于OkHttpClient的注释，我们可以看到OkHttpClient是用于配置我们的连接需求所设计出来的类，当OkHttpClient实例化后它应当是不可变的且可安全的同时开启多个连接，如果有修改OkHttpClient实例的需求，那么可以使用<span class="function"><span class="title">clone</span><span class="params">()</span></span>来获取一份备份来进行安全的修改。</span><br><span class="line"></span><br><span class="line">这是被我们调用的构造函数。</span><br></pre></td></tr></table></figure>
<p>public OkHttpClient() {<br> routeDatabase = new RouteDatabase();<br> dispatcher = new Dispatcher();<br>}</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到，每一个OkHttpClient实例都内嵌着一个routeDatabase实例和一个dispatcher实例，深入这两个类的内部，我们可以了解这两个对象的作用。</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>A blacklist of failed routes to avoid when creating a new connection to a</li>
<li>target address. This is used so that OkHttp can learn from its mistakes: if</li>
<li>there was a failure attempting to connect to a specific IP address or proxy</li>
<li>server, that failure is remembered and alternate routes are preferred.<br>*/<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看到，RouteDatabase类正如它的名字一样，是一个路线数据库，它负责OkHttpClient发起的失败的Connection，将它加入黑名单，我们在之前提到的多<span class="literal">IP</span>重连就是通过这样的记录的方式来实现。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>public final class RouteDatabase {<br>  private final Set<route> failedRoutes = new LinkedHashSet&lt;&gt;();<br>  }<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RouteDatabase内含一个LinkedHashSet来记录所有的失败连接，这个类的实现到这里已经很清楚了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来我们来看看Dispatcher类的内部实现。</span><br></pre></td></tr></table></figure></route></p>
<p>/**</p>
<ul>
<li>Policy on when async requests are executed.<br>*</li>
<li><p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you</p></li>
<li>supply your own executor, it should be able to run {@linkplain #getMaxRequests the</li>
<li>configured maximum} number of calls concurrently.<br>*/<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顾名思义，<span class="variable">Dispatcher</span>是一个调度器，当我们的<span class="variable">OkHttpClient</span>执行异步任务时，<span class="variable">Dispatcher</span>负责控制各个线程间的关系。</span><br><span class="line">看到<span class="variable">ExecutorService</span>时就应该知道了，这个<span class="variable">Dispatcher</span>的内部实现应该就是线程池，并且<span class="ok">ok</span>http还支持我们自定义<span class="function_or_atom">executor</span>，自己来控制各个异步任务。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>public final class Dispatcher {<br>  private int maxRequests = 64;<br>  private int maxRequestsPerHost = 5;</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span> Ready calls in the order they'll be run. <span class="keyword">*</span>/
</code></pre><p>  private final Deque<asynccall> readyCalls = new ArrayDeque&lt;&gt;();</asynccall></p>
<p>  /<em>* Running calls. Includes canceled calls that haven’t finished yet. </em>/<br>  private final Deque<asynccall> runningCalls = new ArrayDeque&lt;&gt;();</asynccall></p>
<p>  /<em>* In-flight synchronous calls. Includes canceled calls that haven’t finished yet. </em>/<br>  private final Deque<call> executedCalls = new ArrayDeque&lt;&gt;();<br>  }<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">这是Dispatcher内部的一段代码，我们可以看到在默认的情况下okhttp最多执行的任务是<span class="number">64</span>个，每个服务端是<span class="number">5</span>个。</span><br><span class="line">Dispatcher内部使用Deque这种双端队列管理AsyncCall，即异步Call，对Dispatcher的分析到这里结束。</span><br><span class="line"></span><br><span class="line">简单的看了一下OkHttpClient的内部实现，下面我们进入Request，分析一下被我们创建的Request。</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpUrl url;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String <span class="function"><span class="keyword">method</span>;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RequestBody body;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object tag;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> URL javaNetUrl; <span class="comment">// Lazily initialized.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> URI javaNetUri; <span class="comment">// Lazily initialized.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> CacheControl cacheControl; <span class="comment">// Lazily initialized.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Request(Builder builder) <span class="comment">&#123;</span><br><span class="line">    this.url = builder.url;</span><br><span class="line">    this.method = builder.method;</span><br><span class="line">    this.headers = builder.headers.build();</span><br><span class="line">    this.body = builder.body;</span><br><span class="line">    this.tag = builder.tag != null ? builder.tag : this;</span><br><span class="line">  &#125;</span></span><br></pre></td></tr></table></figure></call></p>
<p>进入Request内部，我们发现这里并没有什么实际的逻辑，Request类本身只是我们的任务的抽象集合，里面包含了大量的成员变量才是真正有效的逻辑实现体。下面我们去查看Call这个类，去观察一个任务被执行的过程。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A <span class="keyword">call</span> <span class="keyword">is</span> a request that has been prepared <span class="keyword">for</span> execution. A <span class="keyword">call</span> can be</span><br><span class="line"> * canceled. <span class="keyword">As</span> this <span class="built_in">object</span> represents a <span class="built_in">single</span> request/response pair (stream),</span><br><span class="line"> * it cannot be executed twice.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>通过注释我们可以知道，一个Call就是一个可以被执行的Request，Call可以被取消执行，因为一个Call代表一个Request和Response对，所以一个call不能被执行两次。<br>创建Call的构造函数</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Call(OkHttpClient <span class="keyword">client</span>, Request originalRequest) &#123;</span><br><span class="line">  <span class="comment">// Copy the client. Otherwise changes (socket factory, redirect policy,</span></span><br><span class="line">  <span class="comment">// etc.) may incorrectly be reflected in the request when it is executed.</span></span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">client</span> = <span class="keyword">client</span>.copyWithDefaults();</span><br><span class="line">  <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这个构造函数是protected的，因此我们并不能手动new出一个call，这符合逻辑，我们每次想要创建一个call都要通过OkHttpClient的newCall()方法,这个构造函数在这里被调用。</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Prepares <span class="name">the</span> &#123;@code request&#125; <span class="name">to</span> <span class="name">be</span> <span class="name">executed</span> <span class="name">at</span> <span class="name">some</span> <span class="name">point</span> <span class="name">in</span> <span class="name">the</span> <span class="name">future</span>.</span><br><span class="line">  */</span><br><span class="line"> public Call newCall(Request request) &#123;</span><br><span class="line">   return new Call(this, request);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>接下来来观察Call的execute()方法</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">Response</span> execute() throws <span class="type">IOException</span> &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) throw new <span class="type">IllegalStateException</span>(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.getDispatcher().executed(this);</span><br><span class="line">    <span class="type">Response</span> <span class="literal">result</span> = getResponseWithInterceptorChain(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">result</span> == null) throw new <span class="type">IOException</span>(<span class="string">"Canceled"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.getDispatcher().finished(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里Call的执行流程已经很清楚了，一个Call要被执行首先要被创建这个Call的OkHttpClient里的Dispatcher调用加入队列等待，下面我们深入Dispatcher的executed的内部阅读其实现。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> executed(<span class="keyword">Call</span> <span class="keyword">call</span>) &#123;</span><br><span class="line">  executedCalls.add(<span class="keyword">call</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这个方法里只有一行代码，看来还要继续向下找它的真正实现，注意，这里的executedCalls就是我们前面提到的Deque，它实际上是一个队列。这个抽象接口的实现是ArrayDeque，来看看add方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这个add方法把我们要执行的Call加入到了队列的队尾排队，让这个request等待执行。<br>那么队列里的Call什么时候才会被真正执行呢？下面返回Call()的execute()方法，我看可以看到在finish和executed之间的getResponseWithInterceptorChain方法，看来这里就是实际执行部分，进入观察。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override <span class="keyword">public</span> Response proceed(Request request) throws IOException &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">index</span> &lt; <span class="keyword">client</span>.interceptors().size()) &#123;</span><br><span class="line">     <span class="comment">// There's another interceptor in the chain. Call that.</span></span><br><span class="line">     Interceptor.Chain chain = <span class="keyword">new</span> ApplicationInterceptorChain(<span class="keyword">index</span> + <span class="number">1</span>, request, forWebSocket);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">client</span>.interceptors().get(<span class="keyword">index</span>).intercept(chain);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// No more interceptors. Do HTTP.</span></span><br><span class="line">     <span class="keyword">return</span> getResponse(request, forWebSocket);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>getResponse就是实际执行的方法。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Performs the request and returns the response. May return null if this</span><br><span class="line"> * call was canceled.</span><br><span class="line"> */</span></span><br><span class="line">Response getResponse<span class="params">(Request request, boolean forWebSocket)</span> throws IOException &#123;</span><br><span class="line">  <span class="comment">// Copy body metadata to the appropriate request headers.</span></span><br><span class="line">  RequestBody body = request.body<span class="params">()</span>;</span><br><span class="line">  <span class="keyword">if</span> <span class="params">(body != null)</span> &#123;</span><br><span class="line">    Request.Builder requestBuilder = request.newBuilder<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    MediaType contentType = body.contentType<span class="params">()</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(contentType != null)</span> &#123;</span><br><span class="line">      requestBuilder.header<span class="params">(<span class="string">"Content-Type"</span>, contentType.toString<span class="params">()</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long contentLength = body.contentLength<span class="params">()</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(contentLength != -<span class="number">1</span>)</span> &#123;</span><br><span class="line">      requestBuilder.header<span class="params">(<span class="string">"Content-Length"</span>, Long.toString<span class="params">(contentLength)</span>)</span>;</span><br><span class="line">      requestBuilder.removeHeader<span class="params">(<span class="string">"Transfer-Encoding"</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header<span class="params">(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)</span>;</span><br><span class="line">      requestBuilder.removeHeader<span class="params">(<span class="string">"Content-Length"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = requestBuilder.build<span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the initial HTTP engine. Retries and redirects need new engine for each attempt.</span></span><br><span class="line">  engine = new HttpEngine<span class="params">(client, request, <span class="literal">false</span>, <span class="literal">false</span>, forWebSocket, null, null, null, null)</span>;</span><br><span class="line"></span><br><span class="line">  int followUpCount = <span class="number">0</span>;</span><br><span class="line">  while <span class="params">(<span class="literal">true</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(canceled)</span> &#123;</span><br><span class="line">      engine.releaseConnection<span class="params">()</span>;</span><br><span class="line">      throw new IOException<span class="params">(<span class="string">"Canceled"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      engine.sendRequest<span class="params">()</span>;</span><br><span class="line">      engine.readResponse<span class="params">()</span>;</span><br><span class="line">    &#125; catch <span class="params">(RequestException e)</span> &#123;</span><br><span class="line">      <span class="comment">// The attempt to interpret the request failed. Give up.</span></span><br><span class="line">      throw e.getCause<span class="params">()</span>;</span><br><span class="line">    &#125; catch <span class="params">(RouteException e)</span> &#123;</span><br><span class="line">      <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">      HttpEngine retryEngine = engine.recover<span class="params">(e)</span>;</span><br><span class="line">      <span class="keyword">if</span> <span class="params">(retryEngine != null)</span> &#123;</span><br><span class="line">        engine = retryEngine;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Give up; recovery is not possible.</span></span><br><span class="line">      throw e.getLastConnectException<span class="params">()</span>;</span><br><span class="line">    &#125; catch <span class="params">(IOException e)</span> &#123;</span><br><span class="line">      <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">      HttpEngine retryEngine = engine.recover<span class="params">(e, null)</span>;</span><br><span class="line">      <span class="keyword">if</span> <span class="params">(retryEngine != null)</span> &#123;</span><br><span class="line">        engine = retryEngine;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Give up; recovery is not possible.</span></span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = engine.getResponse<span class="params">()</span>;</span><br><span class="line">    Request followUp = engine.followUpRequest<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(followUp == null)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="params">(!forWebSocket)</span> &#123;</span><br><span class="line">        engine.releaseConnection<span class="params">()</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(++followUpCount &gt; MAX_FOLLOW_UPS)</span> &#123;</span><br><span class="line">      throw new ProtocolException<span class="params">(<span class="string">"Too many follow-up requests: "</span> + followUpCount)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(!engine.sameConnection<span class="params">(followUp.httpUrl<span class="params">()</span>)</span>)</span> &#123;</span><br><span class="line">      engine.releaseConnection<span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Connection connection = engine.close<span class="params">()</span>;</span><br><span class="line">    request = followUp;</span><br><span class="line">    engine = new HttpEngine<span class="params">(client, request, <span class="literal">false</span>, <span class="literal">false</span>, forWebSocket, connection, null, null,</span><br><span class="line">        response)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分代码内容非常多，但是我们可以粗略的分为两部分<br>1.重建request，对其做一些修正，不深入探讨。<br>2.创建HttpEngine，在这里发送请求，取得Response。engine里是网络通讯的具体业务逻辑，GZIP压缩也在这里面发挥作用，这部分逻辑非常复杂。<br>到这里一个同步的request调用就分析完了，下面我们再来看看一部的request调用。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  client.getDispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback, forWebSocket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与同步调用相同，这里还是调用Dispatcher让Request进入队列等待执行。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function">ExecutorService <span class="title">getExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里发现了client里excutorService的实现类，原来它就是ThreadPoolExecutor。<br>我截取ThreadPoolExecutor的execute方法的注释</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* Executes the given task sometime in the future.  The task&#10;* may execute in a new thread or in an existing pooled thread.&#10;*&#10;* If the task cannot be submitted for execution, either because this&#10;* executor has been shutdown or because its capacity has been reached,&#10;* the task is handled by the current &#123;@code RejectedExecutionHandler&#125;.&#10;&#10;public void execute(Runnable command) &#123;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>execute接收一个Runnable接口，它真正执行的实际上是Runnable的逻辑，而AyncCall正是一个实现了Runnable的Call的内部类，从而得知执行的就是AyncCall的逻辑。也就是AyncCall的execute方法。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void execute<span class="params">()</span> &#123;</span><br><span class="line">  boolean signalledCallback = <span class="literal">false</span>;</span><br><span class="line">  try &#123;</span><br><span class="line">    Response response = getResponseWithInterceptorChain<span class="params">(forWebSocket)</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(canceled)</span> &#123;</span><br><span class="line">      signalledCallback = <span class="literal">true</span>;</span><br><span class="line">      responseCallback.onFailure<span class="params">(originalRequest, new IOException<span class="params">(<span class="string">"Canceled"</span>)</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      signalledCallback = <span class="literal">true</span>;</span><br><span class="line">      responseCallback.onResponse<span class="params">(response)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch <span class="params">(IOException e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(signalledCallback)</span> &#123;</span><br><span class="line">      <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">      logger.<span class="built_in">log</span><span class="params">(Level.INFO, <span class="string">"Callback failure for "</span> + toLoggableString<span class="params">()</span>, e)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      responseCallback.onFailure<span class="params">(engine.getRequest<span class="params">()</span>, e)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    client.getDispatcher<span class="params">()</span>.finished<span class="params">(this)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这里，又看到了熟悉的代码。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response response = getResponseWithInterceptorChain<span class="list">(<span class="keyword">forWebSocket</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>以后的逻辑和同步调用完全相同。<br>我们梳理整个过程。<br><img src="http://d.pcs.baidu.com/thumbnail/993b67199dbbd8f5341fc33c0bd42096?fid=2104252820-250528-951178632980765&amp;time=1456556400&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2BtawZrwj0f9j%2BNGjiiErCzGP5k%3D&amp;rt=sh&amp;expires=2h&amp;r=526005079&amp;sharesign=unknown&amp;size=c710_u500&amp;quality=100" alt="Alt text"><br>本次到此结束，更多细节以后再进行学习。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/12/15/Retrofit学习记录/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Retrofit学习记录</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="okhttp源码分析" data-title="okhttp源码分析" data-url="http://yoursite.com/2016/02/26/okhttp源码分析/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 王祖亮
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>