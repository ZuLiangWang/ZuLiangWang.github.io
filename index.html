<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo|王祖亮</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="android 安卓">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo|王祖亮">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo|王祖亮">
<meta property="og:description" content="android 安卓">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo|王祖亮">
<meta name="twitter:description" content="android 安卓">
  
    <link rel="alternative" href="/atom.xml" title="Hexo|王祖亮" type="application/atom+xml">
  
  
    <link rel="icon" href="/32.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/touxiang.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">王祖亮</a></h1>
		</hgroup>

		
		<p class="header-subtitle">一只码畜</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/ZuLiangWang" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Hust Cser / Android Coder      zuliangwang@hustunique.com  329851721@qq.com</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王祖亮</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/touxiang.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王祖亮</h1>
			</hgroup>
			
			<p class="header-subtitle">一只码畜</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/ZuLiangWang" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-编译原理实验" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/18/编译原理实验/" class="article-date">
  	<time datetime="2016-10-18T14:04:48.000Z" itemprop="datePublished">2016-10-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="编译原理实验">编译原理实验</h1><p>语法分析&amp;词法分析</p>
<p>Task 1<br>识别词法错误并输出错误信息<br>要求:<br>识别八进制&amp;十六进制 不规范报错<br>识别指数形式浮点数 不规范报错<br>识别 “//“ “/<em> </em>/“注释 并过滤</p>
<p>Task2<br>识别语法错误并输出错误信息</p>
<p>flex使用命令：<br>(1)flex src.l  对给定的flex文件生成对应的c文件<br>注：flex对文件的space非常敏感，不要随便在代码里加空格，否则非常可能不能正常输出。<br>(2)gcc lex.yy.c  -ll -o main 编译c文件生成可执行文件，mac下使用-ll<br>注：因为OSX下的gcc实际上是clang，所以命令和linux下有出入。<br>在mac下man gcc会提示找不到gcc，因为实际这个gcc是clang<br>(3)./main srcFile 把源文件传递给语法分析生成器</p>
<p>正则表达式复习：<br>(1)”.”表示通配符，匹配除了“\n”以外的任何一个字符<br>(2)”[]”表示字符集，即括号内一个字符匹配到则就算匹配到这个字符集。缩写表示法[0-9a-zA-Z]。”^”用在方括号内表示补集。<br>(3)”^”用在方括号外会匹配一行的开头。符号”$”用于匹配一行的结尾。“&lt;<eof>&gt;”匹配文件的结尾。<br>(4)符号”{}”多重含义。A{5}表示AAAAA。A{1，3}表示A、AA或者AAA，即1到3个A。此外，定义的名字要在花括号内，如{letter}。<br>(5)“<em>”表示闭包操作，匹配零个或多个表达式，如X</em>表示零个或多个X<br>(6)“+”表示正闭包操作，匹配一个或多个表达式，用法同上。<br>(7)“?”表示零个或者一个表达式，即有或者无。<br>注：”?”、”*”、”+”都仅仅只对左边临近的那个表达式起效。如abc?表示ab和零个或者多个c<br>(8)”|”表示选择操作,如a|b|c表示a或者b或者c。<br>(9)”\”表示转义字符,与和C语言类似。<br>(10)“””表示忽略转义，如“\n”代表字符串”\n”而不是换行符<br>(11)”/“表示查看输入字符的上下文，如0/1匹配01串中的0而不匹配02中的0。<br>(12)其余剩下的所有字符都表示其本身。</eof></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-okhttp源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/26/okhttp源码分析/" class="article-date">
  	<time datetime="2016-02-26T11:12:59.000Z" itemprop="datePublished">2016-02-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/26/okhttp源码分析/">okhttp源码分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="在前一段时间已经学习了Retrofit和Okhttp的基本用法，今天我就要开始第三部分Why的学习。第一次认真的阅读一个第三方开源库的内部代码，深入理解okttp和Retroft的实现过程，由于Retrofit的网络通讯的实现全部基于okhttp，因此首先我将开始对okhttp源码的学习。">在前一段时间已经学习了Retrofit和Okhttp的基本用法，今天我就要开始第三部分Why的学习。第一次认真的阅读一个第三方开源库的内部代码，深入理解okttp和Retroft的实现过程，由于Retrofit的网络通讯的实现全部基于okhttp，因此首先我将开始对okhttp源码的学习。</h5><hr>
<h2 id="按照惯例，我分三部分开始对okhttp的解析。">按照惯例，我分三部分开始对okhttp的解析。</h2><p>###1.What?<br>okhttp是什么？它有什么用？我直接引用官方的介绍如下</p>
<blockquote>
<p>Overview</p>
<p>HTTP is the way modern applications network. It’s how we exchange data &amp; media. Doing HTTP efficiently makes your stuff load faster and saves bandwidth.<br>OkHttp is an HTTP client that’s efficient by default:</p>
<p>HTTP/2 support allows all requests to the same host to share a socket.<br>Connection pooling reduces request latency (if HTTP/2 isn’t available).<br>Transparent GZIP shrinks download sizes.<br>Response caching avoids the network completely for repeat requests.<br>OkHttp perseveres when the network is troublesome: it will silently recover from common connection problems. If your service has multiple IP addresses OkHttp will attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6 and for services hosted in redundant data centers. OkHttp initiates new connections with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake fails.</p>
<p>Using OkHttp is easy. Its request/response API is designed with fluent builders and immutability. It supports both synchronous blocking calls and async calls with callbacks.</p>
<p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
</blockquote>
<p>根据官方介绍：okhttp是一个应用网络库，它可以帮助我们用更少的带宽和更快的速度去交换数据，有用的使用HTTP。<br>它默认具有以下功能：</p>
<ul>
<li>允许我们发向同一个服务器的请求分享socket</li>
<li>使用链接池的设计来减少请求的延迟</li>
<li>使用GZIP压缩方式减少从服务端下载的数据量</li>
<li>对服务端的回应使用cache避免多次发送完全相同的请求<br>okhttp使用重连机制，当网络出现问题时，它会静默的恢复，并且当你连接的服务有多个IP地址时，它会在第一个连接失败后调用第二个去尝试。<br>okhttp同时支持同步调用和异步调用。</li>
</ul>
<hr>
<p>###2&amp;3.How&amp;Why?</p>
<p>首先从我们的使用过程开始一步一步深入到内部的实现。<br>我们先来看每次使用okhttp的最简单流程。</p>
<p>获取一个URL的内容</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个okhttpclient对象</span></span><br><span class="line">OkHttpClient mOkHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="comment">//创建一个Request</span></span><br><span class="line"><span class="keyword">final</span> Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"www.baidu.com"</span>)</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">//创建一个新的call</span></span><br><span class="line"><span class="keyword">Call</span> <span class="keyword">call</span> = mOkHttpClient.newCall(request); </span><br><span class="line"><span class="comment">//令call进入队列等待执行</span></span><br><span class="line"><span class="keyword">call</span>.enqueue(<span class="keyword">new</span> Callback()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onFailure(Request request, IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onResponse(<span class="keyword">final</span> Response response) <span class="keyword">throws</span> IOException</span><br><span class="line">            &#123;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);       </span><br><span class="line">```      </span><br><span class="line">这是一个典型的最简单的使用方式。</span><br><span class="line"></span><br><span class="line">来简单分析一下它的使用过程。</span><br><span class="line"><span class="number">1</span>.创建一个OkhttpClient对象，这是使用okhttp所有功能的第一步。</span><br><span class="line"><span class="number">2</span>.创建一个Request对象，这个过程使用了建造者模式，这个模式的优点是简化繁琐的初始化过程，使对象的创建与内部的实现分离，让客户端用户可以更精细的根据自己的需求创造对应的对象。我们可以看到，使用了建造者模式，request的创建逻辑变得非常清晰，在这里例子中我们只设置了url，但根据需求我们可以创建复杂得多的request。</span><br><span class="line"><span class="number">3</span>.调用client的方法将request封装成一个<span class="keyword">call</span>，在okhttp中request并不能被直接执行，需要对request进行封装，在最后执行<span class="keyword">call</span>。</span><br><span class="line"><span class="number">4</span>.执行封装好的<span class="keyword">call</span>。查看源码可以看到okhttp为我们提供了两种执行方式，execute()和enqueue()，这两种方式的区别从名字上就能看出来大概，稍后我详细分析。注意，查看源码的注释可以看到</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>A call is a request that has been prepared for execution. A call can be</li>
<li>canceled. As this object represents a single request/response pair (stream),</li>
<li>it cannot be executed twice.<br>*/</li>
</ul>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里明确的指出了一个<span class="keyword">call</span>对象只能被执行一次，所以如果想要多次执行相同的<span class="built_in">request</span>，我们还需要另想办法。</span><br><span class="line"></span><br><span class="line">好了，下面我们开始从源码入手，分析一个<span class="built_in">request</span>从创建到被执行的所有过程。</span><br><span class="line">我们每一次使用都要创建OkhttpClient。</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>Configures and creates HTTP connections. Most applications can use a single</li>
<li>OkHttpClient for all of their HTTP requests - benefiting from a shared</li>
<li>response cache, thread pool, connection re-use, etc.<br>*</li>
<li><p>Instances of OkHttpClient are intended to be fully configured before they’re</p></li>
<li>shared - once shared they should be treated as immutable and can safely be used</li>
<li>to concurrently open new connections. If required, threads can call</li>
<li>{@link #clone()} to make a shallow copy of the OkHttpClient that can be</li>
<li><p>safely modified with further configuration changes.<br>*/</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是官方对于OkHttpClient的注释，我们可以看到OkHttpClient是用于配置我们的连接需求所设计出来的类，当OkHttpClient实例化后它应当是不可变的且可安全的同时开启多个连接，如果有修改OkHttpClient实例的需求，那么可以使用<span class="function"><span class="title">clone</span><span class="params">()</span></span>来获取一份备份来进行安全的修改。</span><br><span class="line"></span><br><span class="line">这是被我们调用的构造函数。</span><br></pre></td></tr></table></figure>
<p>public OkHttpClient() {<br> routeDatabase = new RouteDatabase();<br> dispatcher = new Dispatcher();<br>}</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到，每一个OkHttpClient实例都内嵌着一个routeDatabase实例和一个dispatcher实例，深入这两个类的内部，我们可以了解这两个对象的作用。</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>A blacklist of failed routes to avoid when creating a new connection to a</li>
<li>target address. This is used so that OkHttp can learn from its mistakes: if</li>
<li>there was a failure attempting to connect to a specific IP address or proxy</li>
<li>server, that failure is remembered and alternate routes are preferred.<br>*/<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看到，RouteDatabase类正如它的名字一样，是一个路线数据库，它负责OkHttpClient发起的失败的Connection，将它加入黑名单，我们在之前提到的多<span class="literal">IP</span>重连就是通过这样的记录的方式来实现。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>public final class RouteDatabase {<br>  private final Set<route> failedRoutes = new LinkedHashSet&lt;&gt;();<br>  }<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RouteDatabase内含一个LinkedHashSet来记录所有的失败连接，这个类的实现到这里已经很清楚了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来我们来看看Dispatcher类的内部实现。</span><br></pre></td></tr></table></figure></route></p>
<p>/**</p>
<ul>
<li>Policy on when async requests are executed.<br>*</li>
<li><p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you</p></li>
<li>supply your own executor, it should be able to run {@linkplain #getMaxRequests the</li>
<li>configured maximum} number of calls concurrently.<br>*/<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顾名思义，<span class="variable">Dispatcher</span>是一个调度器，当我们的<span class="variable">OkHttpClient</span>执行异步任务时，<span class="variable">Dispatcher</span>负责控制各个线程间的关系。</span><br><span class="line">看到<span class="variable">ExecutorService</span>时就应该知道了，这个<span class="variable">Dispatcher</span>的内部实现应该就是线程池，并且<span class="ok">ok</span>http还支持我们自定义<span class="function_or_atom">executor</span>，自己来控制各个异步任务。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>public final class Dispatcher {<br>  private int maxRequests = 64;<br>  private int maxRequestsPerHost = 5;</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span> Ready calls in the order they'll be run. <span class="keyword">*</span>/
</code></pre><p>  private final Deque<asynccall> readyCalls = new ArrayDeque&lt;&gt;();</asynccall></p>
<p>  /<em>* Running calls. Includes canceled calls that haven’t finished yet. </em>/<br>  private final Deque<asynccall> runningCalls = new ArrayDeque&lt;&gt;();</asynccall></p>
<p>  /<em>* In-flight synchronous calls. Includes canceled calls that haven’t finished yet. </em>/<br>  private final Deque<call> executedCalls = new ArrayDeque&lt;&gt;();<br>  }<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">这是Dispatcher内部的一段代码，我们可以看到在默认的情况下okhttp最多执行的任务是<span class="number">64</span>个，每个服务端是<span class="number">5</span>个。</span><br><span class="line">Dispatcher内部使用Deque这种双端队列管理AsyncCall，即异步Call，对Dispatcher的分析到这里结束。</span><br><span class="line"></span><br><span class="line">简单的看了一下OkHttpClient的内部实现，下面我们进入Request，分析一下被我们创建的Request。</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpUrl url;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String <span class="function"><span class="keyword">method</span>;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RequestBody body;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object tag;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> URL javaNetUrl; <span class="comment">// Lazily initialized.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> URI javaNetUri; <span class="comment">// Lazily initialized.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> CacheControl cacheControl; <span class="comment">// Lazily initialized.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Request(Builder builder) <span class="comment">&#123;</span><br><span class="line">    this.url = builder.url;</span><br><span class="line">    this.method = builder.method;</span><br><span class="line">    this.headers = builder.headers.build();</span><br><span class="line">    this.body = builder.body;</span><br><span class="line">    this.tag = builder.tag != null ? builder.tag : this;</span><br><span class="line">  &#125;</span></span><br></pre></td></tr></table></figure></call></p>
<p>进入Request内部，我们发现这里并没有什么实际的逻辑，Request类本身只是我们的任务的抽象集合，里面包含了大量的成员变量才是真正有效的逻辑实现体。下面我们去查看Call这个类，去观察一个任务被执行的过程。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A <span class="keyword">call</span> <span class="keyword">is</span> a request that has been prepared <span class="keyword">for</span> execution. A <span class="keyword">call</span> can be</span><br><span class="line"> * canceled. <span class="keyword">As</span> this <span class="built_in">object</span> represents a <span class="built_in">single</span> request/response pair (stream),</span><br><span class="line"> * it cannot be executed twice.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>通过注释我们可以知道，一个Call就是一个可以被执行的Request，Call可以被取消执行，因为一个Call代表一个Request和Response对，所以一个call不能被执行两次。<br>创建Call的构造函数</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Call(OkHttpClient <span class="keyword">client</span>, Request originalRequest) &#123;</span><br><span class="line">  <span class="comment">// Copy the client. Otherwise changes (socket factory, redirect policy,</span></span><br><span class="line">  <span class="comment">// etc.) may incorrectly be reflected in the request when it is executed.</span></span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">client</span> = <span class="keyword">client</span>.copyWithDefaults();</span><br><span class="line">  <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这个构造函数是protected的，因此我们并不能手动new出一个call，这符合逻辑，我们每次想要创建一个call都要通过OkHttpClient的newCall()方法,这个构造函数在这里被调用。</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Prepares <span class="name">the</span> &#123;@code request&#125; <span class="name">to</span> <span class="name">be</span> <span class="name">executed</span> <span class="name">at</span> <span class="name">some</span> <span class="name">point</span> <span class="name">in</span> <span class="name">the</span> <span class="name">future</span>.</span><br><span class="line">  */</span><br><span class="line"> public Call newCall(Request request) &#123;</span><br><span class="line">   return new Call(this, request);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>接下来来观察Call的execute()方法</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">Response</span> execute() throws <span class="type">IOException</span> &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) throw new <span class="type">IllegalStateException</span>(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.getDispatcher().executed(this);</span><br><span class="line">    <span class="type">Response</span> <span class="literal">result</span> = getResponseWithInterceptorChain(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">result</span> == null) throw new <span class="type">IOException</span>(<span class="string">"Canceled"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.getDispatcher().finished(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里Call的执行流程已经很清楚了，一个Call要被执行首先要被创建这个Call的OkHttpClient里的Dispatcher调用加入队列等待，下面我们深入Dispatcher的executed的内部阅读其实现。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> executed(<span class="keyword">Call</span> <span class="keyword">call</span>) &#123;</span><br><span class="line">  executedCalls.add(<span class="keyword">call</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这个方法里只有一行代码，看来还要继续向下找它的真正实现，注意，这里的executedCalls就是我们前面提到的Deque，它实际上是一个队列。这个抽象接口的实现是ArrayDeque，来看看add方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这个add方法把我们要执行的Call加入到了队列的队尾排队，让这个request等待执行。<br>那么队列里的Call什么时候才会被真正执行呢？下面返回Call()的execute()方法，我看可以看到在finish和executed之间的getResponseWithInterceptorChain方法，看来这里就是实际执行部分，进入观察。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override <span class="keyword">public</span> Response proceed(Request request) throws IOException &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">index</span> &lt; <span class="keyword">client</span>.interceptors().size()) &#123;</span><br><span class="line">     <span class="comment">// There's another interceptor in the chain. Call that.</span></span><br><span class="line">     Interceptor.Chain chain = <span class="keyword">new</span> ApplicationInterceptorChain(<span class="keyword">index</span> + <span class="number">1</span>, request, forWebSocket);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">client</span>.interceptors().get(<span class="keyword">index</span>).intercept(chain);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// No more interceptors. Do HTTP.</span></span><br><span class="line">     <span class="keyword">return</span> getResponse(request, forWebSocket);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>getResponse就是实际执行的方法。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Performs the request and returns the response. May return null if this</span><br><span class="line"> * call was canceled.</span><br><span class="line"> */</span></span><br><span class="line">Response getResponse<span class="params">(Request request, boolean forWebSocket)</span> throws IOException &#123;</span><br><span class="line">  <span class="comment">// Copy body metadata to the appropriate request headers.</span></span><br><span class="line">  RequestBody body = request.body<span class="params">()</span>;</span><br><span class="line">  <span class="keyword">if</span> <span class="params">(body != null)</span> &#123;</span><br><span class="line">    Request.Builder requestBuilder = request.newBuilder<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    MediaType contentType = body.contentType<span class="params">()</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(contentType != null)</span> &#123;</span><br><span class="line">      requestBuilder.header<span class="params">(<span class="string">"Content-Type"</span>, contentType.toString<span class="params">()</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long contentLength = body.contentLength<span class="params">()</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(contentLength != -<span class="number">1</span>)</span> &#123;</span><br><span class="line">      requestBuilder.header<span class="params">(<span class="string">"Content-Length"</span>, Long.toString<span class="params">(contentLength)</span>)</span>;</span><br><span class="line">      requestBuilder.removeHeader<span class="params">(<span class="string">"Transfer-Encoding"</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header<span class="params">(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)</span>;</span><br><span class="line">      requestBuilder.removeHeader<span class="params">(<span class="string">"Content-Length"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = requestBuilder.build<span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the initial HTTP engine. Retries and redirects need new engine for each attempt.</span></span><br><span class="line">  engine = new HttpEngine<span class="params">(client, request, <span class="literal">false</span>, <span class="literal">false</span>, forWebSocket, null, null, null, null)</span>;</span><br><span class="line"></span><br><span class="line">  int followUpCount = <span class="number">0</span>;</span><br><span class="line">  while <span class="params">(<span class="literal">true</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(canceled)</span> &#123;</span><br><span class="line">      engine.releaseConnection<span class="params">()</span>;</span><br><span class="line">      throw new IOException<span class="params">(<span class="string">"Canceled"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      engine.sendRequest<span class="params">()</span>;</span><br><span class="line">      engine.readResponse<span class="params">()</span>;</span><br><span class="line">    &#125; catch <span class="params">(RequestException e)</span> &#123;</span><br><span class="line">      <span class="comment">// The attempt to interpret the request failed. Give up.</span></span><br><span class="line">      throw e.getCause<span class="params">()</span>;</span><br><span class="line">    &#125; catch <span class="params">(RouteException e)</span> &#123;</span><br><span class="line">      <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">      HttpEngine retryEngine = engine.recover<span class="params">(e)</span>;</span><br><span class="line">      <span class="keyword">if</span> <span class="params">(retryEngine != null)</span> &#123;</span><br><span class="line">        engine = retryEngine;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Give up; recovery is not possible.</span></span><br><span class="line">      throw e.getLastConnectException<span class="params">()</span>;</span><br><span class="line">    &#125; catch <span class="params">(IOException e)</span> &#123;</span><br><span class="line">      <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">      HttpEngine retryEngine = engine.recover<span class="params">(e, null)</span>;</span><br><span class="line">      <span class="keyword">if</span> <span class="params">(retryEngine != null)</span> &#123;</span><br><span class="line">        engine = retryEngine;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Give up; recovery is not possible.</span></span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = engine.getResponse<span class="params">()</span>;</span><br><span class="line">    Request followUp = engine.followUpRequest<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(followUp == null)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="params">(!forWebSocket)</span> &#123;</span><br><span class="line">        engine.releaseConnection<span class="params">()</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(++followUpCount &gt; MAX_FOLLOW_UPS)</span> &#123;</span><br><span class="line">      throw new ProtocolException<span class="params">(<span class="string">"Too many follow-up requests: "</span> + followUpCount)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(!engine.sameConnection<span class="params">(followUp.httpUrl<span class="params">()</span>)</span>)</span> &#123;</span><br><span class="line">      engine.releaseConnection<span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Connection connection = engine.close<span class="params">()</span>;</span><br><span class="line">    request = followUp;</span><br><span class="line">    engine = new HttpEngine<span class="params">(client, request, <span class="literal">false</span>, <span class="literal">false</span>, forWebSocket, connection, null, null,</span><br><span class="line">        response)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分代码内容非常多，但是我们可以粗略的分为两部分<br>1.重建request，对其做一些修正，不深入探讨。<br>2.创建HttpEngine，在这里发送请求，取得Response。engine里是网络通讯的具体业务逻辑，GZIP压缩也在这里面发挥作用，这部分逻辑非常复杂。<br>到这里一个同步的request调用就分析完了，下面我们再来看看一部的request调用。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  client.getDispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback, forWebSocket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与同步调用相同，这里还是调用Dispatcher让Request进入队列等待执行。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function">ExecutorService <span class="title">getExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里发现了client里excutorService的实现类，原来它就是ThreadPoolExecutor。<br>我截取ThreadPoolExecutor的execute方法的注释</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* Executes the given task sometime in the future.  The task&#10;* may execute in a new thread or in an existing pooled thread.&#10;*&#10;* If the task cannot be submitted for execution, either because this&#10;* executor has been shutdown or because its capacity has been reached,&#10;* the task is handled by the current &#123;@code RejectedExecutionHandler&#125;.&#10;&#10;public void execute(Runnable command) &#123;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>execute接收一个Runnable接口，它真正执行的实际上是Runnable的逻辑，而AyncCall正是一个实现了Runnable的Call的内部类，从而得知执行的就是AyncCall的逻辑。也就是AyncCall的execute方法。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void execute<span class="params">()</span> &#123;</span><br><span class="line">  boolean signalledCallback = <span class="literal">false</span>;</span><br><span class="line">  try &#123;</span><br><span class="line">    Response response = getResponseWithInterceptorChain<span class="params">(forWebSocket)</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(canceled)</span> &#123;</span><br><span class="line">      signalledCallback = <span class="literal">true</span>;</span><br><span class="line">      responseCallback.onFailure<span class="params">(originalRequest, new IOException<span class="params">(<span class="string">"Canceled"</span>)</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      signalledCallback = <span class="literal">true</span>;</span><br><span class="line">      responseCallback.onResponse<span class="params">(response)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch <span class="params">(IOException e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(signalledCallback)</span> &#123;</span><br><span class="line">      <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">      logger.<span class="built_in">log</span><span class="params">(Level.INFO, <span class="string">"Callback failure for "</span> + toLoggableString<span class="params">()</span>, e)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      responseCallback.onFailure<span class="params">(engine.getRequest<span class="params">()</span>, e)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    client.getDispatcher<span class="params">()</span>.finished<span class="params">(this)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这里，又看到了熟悉的代码。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response response = getResponseWithInterceptorChain<span class="list">(<span class="keyword">forWebSocket</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>以后的逻辑和同步调用完全相同。<br>我们梳理整个过程。<br><img src="http://d.pcs.baidu.com/thumbnail/993b67199dbbd8f5341fc33c0bd42096?fid=2104252820-250528-951178632980765&amp;time=1456556400&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2BtawZrwj0f9j%2BNGjiiErCzGP5k%3D&amp;rt=sh&amp;expires=2h&amp;r=526005079&amp;sharesign=unknown&amp;size=c710_u500&amp;quality=100" alt="Alt text"><br>本次到此结束，更多细节以后再进行学习。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Retrofit学习记录" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/15/Retrofit学习记录/" class="article-date">
  	<time datetime="2015-12-15T13:27:28.000Z" itemprop="datePublished">2015-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/15/Retrofit学习记录/">Retrofit学习记录</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近花了点时间了解学习了一下Retrofit库，现在记录一下。</p>
<h2 id="一-What_Retrofit是什么？有什么用？">一.What 　Retrofit是什么？有什么用？</h2><p>Retrofit是一个Android下非常流行的网络请求库。<br>按照官方的介绍就是</p>
<blockquote>
<p>A type-safe REST client for Android and Java</p>
</blockquote>
<p>注意，Retrofit是一个基于==REST==的客户端请求库。<br>在学习Retrofit之前我们需要了解REST的概念，这也是使用这个库最大的难点，我大部分时间也都花在这个部分上。</p>
<p>那么，现在我们来介绍REST这个概念。<br>REST全称为Representation State Transfer，翻译过来就是表征状态转移。<br>它是一种特定的互联网架构，符合这种架构的软件，我们称它为==<em>RESTful</em>==<br>光看名字非常的抽象，但是我理解REST这个概念就是通过一个博客上对这个名字的解析。下面用我的语言重新来介绍一遍上面几个名词。</p>
<h4 id="Representation">Representation</h4><p>这个词是最不好理解的，要弄懂这个词的意思，首先我们要弄明白Resource的概念。<br>Resource，即资源，我们现在使用互联网其实就是在访问互联网上的一个个资源并组织使用它们。不管是客户端还是直接通过浏览器，我们要上网需要做的事情是什么？通过网络获取特定的信息并显示为符合我们要求的形式给我们阅读。<br>在这个过程中，首先通过URI（Uniform Resource Identifier）即唯一定位这个资源的标识符来访问这个资源，这个资源就是在服务器中存储的信息，它可以是图片、视频、任何东西，总之就是一些被保存在硬盘里的文件，我们在访问了它们之后，服务器按照规定的格式将这个文件返回给访问者，这样就完成了资源的调用。<br>那么Representation在这个过程中是什么样的一个概念呢？<br>在我们使用URI的过程中，我们并不指定这个资源的格式，因为URI仅仅代表这个文件的访问路径，而这个路径不应该包含这个资源它本身的格式和内容，因此Representation（表征）即指这个资源的表示形式。这种形式可以是JPG、JSON、XML、HTML、AVI。</p>
<h4 id="State_Transfer">State Transfer</h4><p>通过上面的阅读，我们知道了在访问过程中我们使用URI仅仅只是得到了这个资源，那么将这个资源转换成Represtation的这个过程即为State Transfer（状态转换）。这个转换过程发生在服务器上，我们在客户端通过HTTP协议向服务器发送请求去控制这个过程，要求服务器返回我们希望的内容。</p>
<h3 id="综上所诉">综上所诉</h3><p>我直接引用我学习的博客中的总结，我认为非常的精炼。</p>
<blockquote>
<p>综合上面的解释，我们总结一下什么是RESTful架构：<br>　　（1）每一个URI代表一种资源；<br>　　（2）客户端和服务器之间，传递这种资源的某种表现层；<br>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
</blockquote>
<h2 id="二-How_Retrofit的使用">二.How 　Retrofit的使用</h2><p>理解了REST的概念，接下来就可以学习Retrofit的具体使用了。<br>使用步骤</p>
<h4 id="1-创建一个Retrofit实例">1.创建一个Retrofit实例</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">public</span> static final <span class="keyword">String </span><span class="keyword">BASE_URL </span>= <span class="string">"http://api.myservice.com/"</span><span class="comment">;</span></span><br><span class="line"><span class="label">Retrofit</span> retrofit = new Retrofit.<span class="keyword">Builder()</span><br><span class="line"></span>    .<span class="keyword">baseUrl(BASE_URL)</span><br><span class="line"></span>    .<span class="keyword">addConverterFactory(GsonConverterFactory.create())</span><br><span class="line"></span>    .<span class="keyword">build();</span></span><br></pre></td></tr></table></figure>
<p>可以看到，根据REST架构，首先我们确定我们所访问的Api的资源基本URI，这个URI是这一批接口的公共前缀。<br>我们要使用的具体的每一个Api都是BASE_URL/xxx/xxx这种形式。<br>接下来创建一个Retrofit实例，将这个BaseURL传入，并指定Retrofit解析这个资源使用的解析库，具体使用哪一个需要具体分析，这里不再叙述。</p>
<blockquote>
<p>有如下的解析库可以选择：<br>Converter    Library<br>Gson    com.squareup.retrofit:converter-gson:2.0.0-beta2<br>Jackson    com.squareup.retrofit:converter-jackson:2.0.0-beta1<br>Moshi    com.squareup.retrofit:converter-moshi:2.0.0-beta1<br>Protobuf    com.squareup.retrofit:converter-protobuf:2.0.0-beta1<br>Wire    com.squareup.retrofit:converter-wire:2.0.0-beta1<br>Simple XML    com.squareup.retrofit:converter-simplexml:2.0.0-beta1</p>
</blockquote>
<p>这样，我们就创建了一个符合我们要求的retrofit实例了。</p>
<h4 id="2-根据我们使用接口返回数据的格式创建对应的实体类">2.根据我们使用接口返回数据的格式创建对应的实体类</h4><p>这里我推荐使用一款Android Studio插件GsonFormat，根据字符串一键生成对应的实体类。</p>
<h4 id="3-创建对应的接口">3.创建对应的接口</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">public</span> <span class="tag">interface</span> <span class="tag">ApiInterface</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">@GET</span>(<span class="string">"users/&#123;username&#125;"</span>)</span><br><span class="line">Call&lt;User&gt; <span class="function">getUser</span>(<span class="variable">@Path</span>(<span class="string">"username"</span>) String username);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个Retrofit接口一共需要指定两样东西。<br>(1)指定HTTP的动作<br>我们可以选择的参数有四个，分别为：<br>GET<br>POST<br>PUT<br>DELETE<br>不清楚这几个动作在HTTP中的具体的含义的同学可以自行百度再仔细研究。<br>这里我推荐一篇文章：<br><a href="get,put,post,delete含义与区别">http://286.iteye.com/blog/1420713</a><br>在后面的参数为BASE_URL后另加入的地址，从而指定我们要调用的Api的URL。<br><em>这里有一个坑！</em><br>BaseURL和@GET后的附加的URL的问题。<br>我使用的retrofit2.0在BaseURL后的URL必须以/结尾！！<br>也就是说</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//api.myservice.com/</span></span><br><span class="line"><span class="string">http:</span><span class="comment">//api.myservice.com</span></span><br></pre></td></tr></table></figure>
<p>是不同的！这个/你不能接在@GET中的URL的附加中，retrofit对这一点有绝对的要求，如果你像后面一样，你就会成功接收到返回的数据，但是狂报404..请记住这点<br>(2)创建在Api调用完成后被回调的函数。<br>在Retrofit2.0之前这个回调函数是可以有两种定义模式的，分别为同步与异步，但是在2.0删除了同步的写法，目前只有一种异步的定义方式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Call</span>&lt;<span class="keyword">User</span>&gt; getUser(@<span class="keyword">Path</span>(<span class="string">"username"</span>) <span class="keyword">String</span> username);</span></span><br></pre></td></tr></table></figure>
<p>Call的泛型中的类型即为完成调用后解析得到的实体类的类型。<br>在方法中同时可以使用特殊的注解。<br>这里有几种特殊的注解参数可以选择</p>
<blockquote>
<p>@Path<br>使用@Path注解可以将URL中的变量替换为注定的值。<br>@Query<br>使用@Query注解可以提供查询参数，这个注解结合POST使用。<br>@Body<br>使用@Body注解可以将指定类型的对象直接发送到服务器。<br>剩下的注解可以在使用时再具体查询，我这里对我认为不太重要的注解不再介绍。<br>(3)执行我们创建的call。<br>如果想要在当前线程执行call。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">call</span>.<span class="keyword">execute</span>();</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>一行代码即可。<br>如果想要在另外一个新线程中执行enqueue<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call.<span class="function"><span class="title">enqueue</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用令call入队等待执行。<br>注意每一个Call仅能执行一次，如果想要再次执行这个Call，就必须再创建一个新的Call，官方当然给了我们解决方法。使用call.clone()即可复制一个完全一样的Call。</p>
<p>下面附上我项目中使用的一个完整的实例。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder<span class="params">()</span></span><br><span class="line">                        .baseUrl<span class="params">(ApiConfig.ZHIHU_BASE)</span></span><br><span class="line">                        .addConverterFactory<span class="params">(GsonConverterFactory.create<span class="params">()</span>)</span></span><br><span class="line">                        .build<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StartImageInterface startImageInterface= retrofit.create<span class="params">(StartImageInterface.class)</span>;</span><br><span class="line"></span><br><span class="line">retrofit.Call&lt;StartGsonBean&gt; beanCall = startImageInterface.startImage<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">beanCall.enqueue<span class="params">(new retrofit.Callback&lt;StartGsonBean&gt;<span class="params">()</span> &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse<span class="params">(retrofit.Response&lt;StartGsonBean&gt; response, Retrofit retrofit)</span> &#123;</span><br><span class="line">            Log.d<span class="params">(<span class="string">"TAG"</span>,response.body<span class="params">()</span>.getImg<span class="params">()</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure<span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        t.printStackTrace<span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StartImageInterface</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@GET</span>(ApiConfig.START_IMAGE)</span><br><span class="line">    <span class="function">Call&lt;StartGsonBean&gt; <span class="title">startImage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，Retrofit使用的基本介绍到这里就结束了。</p>
<p>##三.Why Retrofit实现的原理<br>这一块内容还是等我水平足够再仔细研究。。</p>
<p>##四.其它<br>如果要学习Retrofit，请在官方处下载当前最新的2.0，而且注意，2.0与之前的版本有较大差异，如果要查询相关的问题，请记得注意Retrofit的版本问题，有不少研究Retrofit的文章已经过时了。</p>
<p>使用Retrofit+Okhttp，完美解决网络调用问题。<br>注意，Retrofit只有在Api符合REST规范，即它是RESTful时，我们使用才足够的方便。如果碰上一些个别的奇葩Api，这个时候我们可以使用Okhttp来解决问题，Okhttp是Squre的另一个网络通讯库，而且Retrofit的底层也正是基于Okhttp实现的，可以说，Retrofit就是以Okhttp为骨架，封装了一些另外的功能，从而方便我们调用RESTful的专用库。因此Okhttp的用法与Retrofit几乎相同，我们使用时也不用考虑什么兼容问题，放心大胆的使用就可以了！</p>
<p>Retrofit官方网站</p>
<p><a href="http://square.github.io/retrofit/#introduction" target="_blank" rel="external">Retrofit</a></p>
<p>OkHttp官方网站<br><a href="http://square.github.io/okhttp/" target="_blank" rel="external">OkHttp</a><br>参考博客<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3460.html" target="_blank" rel="external">Retrofit 2.0：有史以来最大的改进</a><br><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">理解RESTful架构</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-rxJava详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/13/rxJava详解/" class="article-date">
  	<time datetime="2015-12-13T10:43:47.000Z" itemprop="datePublished">2015-12-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/13/rxJava详解/">rxJava详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个周六一整天都在学习rxJava，又涨了不少姿势。</p>
<h2 id="一-What?_rxJava是什么，它有什么用，有什么优点">一.What?　rxJava是什么，它有什么用，有什么优点</h2><p>rxJava是一套函数响应式Java编程框架。整套结构基于观察者模式，它能够解决我们头疼的异步问题，结合rxAndroid可以完全抛弃Android原生的AsyncTask。其链式调用方式让整个思维过程变得清晰流畅。</p>
<p>这里着重介绍rxJava的优点：<br>1.<strong>一套完整的异步解决方案</strong>。<br>与AsyncTask相比更加优雅，而且支持的功能更加强大。更重要的是，由于Acitivty生命周期的影响，AsyncTask存在极大的隐患，我们在使用AsyncTask时通常以内部类的形式嵌入Activity中，因为AsyncTask隐式持有Activity的引用，<strong>但是AsyncTask如果不被cancel或者将其任务执行完毕，它就不会被回收</strong>，因为两者生命周期不同步，当执行耗时任务或者手机屏幕旋转导致Activity被销毁时极有可能造成内存泄露！使用rxJava和rxAndroid可以轻松解决这个问题。</p>
<p>2.<strong>链式调用。</strong><br>rxJava整个使用过程中是没有组合嵌套的。因此它不会造成多余的耦合，而且其过程非常清晰，甚至不需要很复杂的注释就能读懂整个过程的逻辑。<br>它的调用过程大概是这样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.map(fun)&#10;.subscribeOn(thread)&#10;.observeOn(thread)&#10;.suscribe(new  Action&#123;&#10;    public void call(params)&#123;&#10;    &#125;&#10;  &#125; )</span><br></pre></td></tr></table></figure>
<p>可以看到，整个调用过程的逻辑是非常清晰的。</p>
<p>3.<strong>强大的map和filter功能。</strong><br>rxJava引入了很多函数式编程的思想，恰巧我最近正在看《计算机程序的构造与解释》，学习了一些List的方言Scheme的语法知识，简单了解了函数式编程中的一些思想。rxJava引入的map和filter就是函数式编程中非常重要的概念，map是一种映射变换的思想，通过map我们可以把一种Observable变换成另一种Observable，这是一种闭包的性质，我们可以通过map得到任何我们想要的Observable，在Android开发过程的直接体现就是我们可以把传入Observable的参数转化为任意的另外一个参数！<br>比如我在项目中使用的一个例子：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.just<span class="params">(faceBitmap)</span></span><br><span class="line">          .map<span class="params">(new Func1&lt;Bitmap, DetectFaceInteractor&gt;<span class="params">()</span> &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public DetectFaceInteractor call<span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">                        JSONObject respsonse = null;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            respsonse = youtu.FaceShape<span class="params">(faceBitmap, <span class="number">0</span>)</span>;</span><br><span class="line">                            FacePositionModel model = gson.fromJson<span class="params">(respsonse.toString<span class="params">()</span>, FacePositionModel.class)</span>;</span><br><span class="line">                            detectFaceInteractor = new DetectFaceInteractorImpl<span class="params">(model, BitmapRich.toGrayscale<span class="params">(faceBitmap)</span>)</span>;</span><br><span class="line">                        &#125; catch <span class="params">(IOException e)</span> &#123;</span><br><span class="line">                            e.printStackTrace<span class="params">()</span>;</span><br><span class="line">                        &#125; catch <span class="params">(JSONException e)</span> &#123;</span><br><span class="line">                            e.printStackTrace<span class="params">()</span>;</span><br><span class="line">                        &#125; catch <span class="params">(KeyManagementException e)</span> &#123;</span><br><span class="line">                            e.printStackTrace<span class="params">()</span>;</span><br><span class="line">                        &#125; catch <span class="params">(NoSuchAlgorithmException e)</span> &#123;</span><br><span class="line">                            e.printStackTrace<span class="params">()</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        return detectFaceInteractor;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span></span><br></pre></td></tr></table></figure>
<p>通过map我实现了一个变换：<br>将传入的bitmap通过指定接口得到Json格式的数据，并通过Gson解析成一个JavaBean，最后传入Interactor得到一个业务类！<br>注意，这里的map的参数一个匿名内部类fun，实际上我们这个需要的仅仅是一个处理变换过程的函数，但是由于Java是面向对象的语言，很多时候我们迫不得已使用了大量的匿名内部类来实现这种仅有一个函数起作用的类。这也是与函数式编程不同的地方，在函数式编程中可以直接把一个函数A当做参数传入另一个函数B，函数B就叫做高阶函数，这种实现方式在Java8中已经通过lambda表达式引入了Java中，之所以称rxJava为函数式的框架，也是因为这个原因，它其中引入了很多函数式编程的概念，因此如果要使用rxJava，配合lambda表达式会把你的代码简化到极致！</p>
<h2 id="二-How？_rxjava怎么使用">二.How？　rxjava怎么使用</h2><p>要学会如何使用rxJava，我们需要弄明白三块内容</p>
<p>1.<strong>观察者模式。</strong><br>rxJava的整个架构都是基于观察者模式，如果你不理解这种设计模式，在使用时你将寸步难行。<br>什么是观察者模式？<br>在Java使用时你有没有发现在很多情况下，一个对象的变化依赖于另一个对象的变化，我们将这种通用的情况抽出来进行总结，将其称之为观察者模式。观察者模式存在一个观察者和一个被观察者，当被观察者对象发现变化时，它将通知与它关联的观察者，这时观察者就将做出相应的应对。<br>简单的来说，观察者模式的实现方式就是</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">Observable.onChange()&#123;</span><br><span class="line"> observer<span class="string">.changeWithIt</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>具体的就不再展开。</p>
<p>2.<strong>rxJava的重要类和接口</strong><br>rxJava中最重要的几个接口和类的关系理清楚时你就将明白它是如何实现观察者模式。<br>（1）Observable类 被观察者<br>（2）Observer接口  观察者<br>（3）Subscribe类   订阅者，注意这个类是Observable类的子<br>类，同时又是Observer的实现类。这点可能有些奇怪，我们暂且不去深究这样设计的意义。<br>（4）Function接口  实现函数式编程中对应的函数参数<br>（5）Action接口       Function的子接口，起到简化使用的作用<br>由名字就可以知道前几个关键类在观察者模式对应的地位。后面两个接口在使用时再仔细研究。<br>暂且就到这里。</p>
<p>3.<strong>函数式编程思想</strong><br>如果没有接触过函数式编程，直接学习rxJava会非常难以适应其中大量的陌生概念。这里主要说明几个我目前接触到的相关概念。<br>（1）高阶函数<br>    以函数为参数的函数被称为高阶函数，在Java中没有对应的概念，为了实现高阶函数，我们经常使用匿名内部类来替代函数传入，这让Java代码变得非常臃肿，在Java8中引入lambda表达式就是实现了这个功能，想要深入学习的同学可以再深入的去砍一下lambda表达式的相关内容。<br>（2）闭包映射<br>当一个结构满足闭包性质时，即对它进行的一系列操作返回的都是另一个相应的结构时，我们就可以以此为基础构建更大更抽象的结构。这其实就是封装的概念，在Java中直接的体现就是类和对象，一个对象我们去操作它的成员，最终返回同一个类的另一种对象，我们把这个类当做砖从而去造大房子，map和filter就作用在这类结构上，理论上我们可以使用它们构造出所有我们需要的砖。</p>
<h2 id="三-Why？_rxjava的实现原理">三.Why？　rxjava的实现原理</h2><p>这一部分内容留置以后研究。</p>
<p>参考资料<br><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a> </p>
<p>Github<br><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">rxJava</a><br><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">rxAndroid</a></p>
<p>在AndroidStudio中使用lambda表达式<br><a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="external">gradle-retrolambda</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 王祖亮
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>